---
layout: post
title: 数据结构-王道
categories: [数据结构]
description: 王道考研笔记
keywords: 数据结构
---

# 数据结构-王道

## 1.绪论

世界现在将现实世界信息化，掌握数据结构，操作系统，计算机组成原理，计算机网络才能让我们更好的探索信息化世界

### 1.基本概念和术语

数据结构的基本概念，什么是算法，算法的时间复杂度，算法的空间复杂度

数据结构的基本概念：1. 数据 2. 数据元素、数据项 3. 数据对象、数据结构

1. 数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的数据的集合，数据是计算机加工的原料，早期计算机处理纯数值的问题，现在可以处理非数值型问题，数据的个体信息，数据之间的逻辑关系
2. 数据元素：数据元素是数据的基本单位，通常作为一个整体来考虑和处理，一个数据元素由多个数据项组成，

3. 数据项：是数据元素不可分割的最小单位

4. 数据对象：具有相同性质的数据元素的集合，是数据的一个子集
5. 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合

### 2.数据结构的三要素

1. 逻辑结构
   1. ~~集合~~
   2. 线性
   3. 树形
   4. 图

2. 数据的运算 `结合逻辑结构、实际需求来定义基本运算`
3. 物理结构（存储结构）
   - 顺序存储 `逻辑上是连续的，物理上也是连续的`
   - 链式存储 `逻辑上是连续的，物理上是不相邻的`
   - 索引存储 `存储元素的同时，建立附加的索引表，索引表中的每项称为索引项，索引项的一半形式是（关键字，地址）`
   - 散列存储 `根据元素的关键字计算出该元素的存储地址，又称为hash存储`


确定了逻辑结构和数据的运算，就确定了数据结构的定义

#### 数据类型和抽象数据类型

##### 数据类型是一个值的集合和定义在此集合上的一组操作的总称

1. 原子类型 `其值不可再分的数据类型`
2. 结构类型 `其值可以在分解为若干成分（分量）的数据类型`

##### 抽象数据类型

> ADT，抽象数据组织及与之相关的操作（struct）

### 3.算法的基本概念

程序 = 数据结构（是要处理的信息） + 算法（如何高效的处理这些数据，以解决实际问题）

> **算法** 是对特定问题<font color=red>求解步骤</font>的一种描述，它是指令的优先序列，其中的每条指令表示一个或多个操作

#### 算法的特性

1. 有穷性：算法必须是有穷的，而程序是无穷的
2. 确定性：确定算法每条指令必须有确切的含义，对于相同的输入只能得出相同的输出
3. 可行性：算法描述的操作都可以通过已经实现的基本运算执行有限次来实现
4. 输入和输出：一个算法有零个和多个输入，这些输入取自于某个特定的对象的集合，有一个或多个输出，这些输出是与输入有着某种特定关系的量

#### 好算法的特质

1. 正确性 算法应该能够正确的解决问题
2. 可读性 算法应具有良好的可读性，以帮助人们理解（注释）
3. 健壮性 当输入非法数据时，算法能够适当的做出反应或进行处理，而不会产生莫名其妙的输出结果
4. 高效率和低存储量需求 耗费的时间少，时间复杂度低，耗用内存少，空间复杂度低

### 4.算法的时间复杂度

**事前预估**算法时间开销T(n)与问题规模n的关系

当问题规模足够大时，可以只考虑阶数高的部分

![image-20221205171232052](https://s2.loli.net/2022/12/08/BaYzbVKA76UIQ9l.png)

![image-20220927190138135](https://s2.loli.net/2022/12/08/9OQWqBLg37nMZaD.png)

![cifnL1M5lsNXFyI](https://s2.loli.net/2022/12/08/ZX1ca9Et2NCSFPn.png)

**口令**：<font color=grayblue>常对幂指阶</font>

时间复杂度存在多种情况时，最坏时间复杂度，平均时间复杂度，最好时间复杂度

##### 如何计算

1. 找到一个基本操作（最深层循环）
2. 分析该基本操作的执行次数X与问题规模n的关系 x = f(n)
3. x的数量级O(x)就是算法时间复杂度T(n)

> 算法性能：很多算法的性能问题只有在n很大时才能暴露出来

### 算法的空间复杂度

内存中的程序代码的存储空间是固定的，和问题规模是没有关系的

1. 无论问题规模怎么变，算法运行时所需的内存空间都是固定的常量，算法的空间复杂度都是O(1)，算法<font color=red>原地工作</font>，算法所需内存空间为常量
2. 算法空间复杂度同样适用加法法则和乘法法则

内存：

- 程序代码，数据

![image-20221205184511585](https://s2.loli.net/2022/12/08/OB1xyfpUMjerJzC.png)

## 2.线性表

### 1.线性表的定义和基本操作

`数据结构三要素：逻辑结构、数据的运算、存储结构（物理结构）`

#### 定义

线性表是具有相同数据类型的n个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表，若用L命名线性表，则表示为：L=(a1, a2, a3, ..., ai, ..., an)（Linear List）

- *第i个*
- *表头元素*
- *表尾元素*
- *直接前驱*
- *直接后继*

#### 基本操作

- initList：`初始化表，构造一个空的线性表L，分配内存空间`
- destroyList：`销毁操作，销毁线性表，并释放线性表占用的内存空间`
- listInsert：`插入操作，在比阿中的第i个位置插入指定元素e`
- listDelete：`删除操作，删除表中第i个位置的元素，并用e返回删除元素的值`
- locateElem：按值查找
- getElem：按位查找

其他操作

- length：求表长
- printList：输出操作
- empty：判空操作

> Tips：
>
> 1. 对数据的操作（记忆思路）--创销、增删改查
> 2. C语言函数的定义--<返回值类型> 函数名 (<参数1类型> 参数1, <参数2类型 参数2>, ......)
> 3. 实际开发中，可根据实际需求定义其他的基本操作
> 4. 函数名和参数的形式，命名都可变
> 5. 什么时候要传入引用类型的参数，需要在修改后带回来

为什么要实现对数据结构的基本操作？

1. 团队合作编程
2. 避免重复工作，降低出错风险

### 2.顺序表的定义

`顺序表一一用顺序存储的方式实现线性表顺序存储。`

把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。

![image-20221206153210914](https://s2.loli.net/2022/12/08/Q4DdvisFzJNlokW.png)

获取数据元素大小`sizeof(ElemType)`

#### 静态分配

```c++
// 静态的大小
#include <stdio.h>
#include <iostream>

#define MaxSize 10

typedef struct {
    int data[MaxSize];
    int length;
} SeqList;

void InitList(SeqList &L) {
//  for(int i = 0; i < MaxSize; i++)
//    L.data[i] = 0;
    L.length = 0;
}

int main() {
    SeqList L;
    InitList(L);
    for (int i = 0; i < MaxSize; ++i) {
        printf("data[%d]=%d\n", i, L.data[i]);
    }
    return 0;
}
```

静态数组存满了怎么办？

* 无法更改，因为存储空间是静态的

#### 动态分配

```c++
// 动态分配
#define InitSize 10

#include <cstdlib>
#include "stdio.h"

// 动态申请和释放内存空间
typedef struct {
    int *data;
    int MaxSize;
    int length;
} SeqList;
// 申请一片连续的存储空间
void InitList(SeqList &L) {
    L.data = (int *)malloc(InitSize * sizeof(int));
    L.length = 0;
    L.MaxSize = InitSize;
}
/*
增加动态数组的长度，申请新的内存区域后，需要free释放原来占用的内存
*/
void IncreaseSize(SeqList &L, int len) {
    int *p = L.data;
    L.data = (int *) malloc((L.MaxSize + len) * sizeof(int));
    for (int i = 0; i < L.length; ++i) {
        L.data[i] = p[i];
    }
    L.MaxSize = L.MaxSize + len;
    free(p);
}

int main() {
    SeqList L;
    InitList(L);
    IncreaseSize(L, 5);
    for (int i = 0; i < L.MaxSize; ++i) {
        printf("data[%d] = %d\n", i, L.data[i]);
    }
    return 0;
}
```

realloc也可以实现malloc和free

#### 顺序表的特点：

1. 随机访问：可以在O(1)时间内找到第i个元素
2. 存储密度高，每个节点只存储数据元素
3. 拓展容量不方便（即使采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
4. 插入、删除操作不方便，需要移动大量元素

### 3.顺序表的基本操作

#### 插入

```c++
bool ListInsert(SeqList &L, int i, int e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length == MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}
// 最好时间复杂度O(1)
// 最坏时间复杂度O(n)
// 平均时间复杂度O(n)
```

#### 删除

```c++
bool ListDelete(SeqList &L, int i, int &e) {
    if (i < 1 || i > L.length) {
        return false;
    }
    e = L.data[i -1];
    for (int j = i; j < L.length; j++) {
        L.data[j - 1] = L.data[j];
    }
    L.length--;
    return true;
}
```

